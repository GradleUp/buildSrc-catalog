/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import org.gradle.api.Plugin
import org.gradle.api.artifacts.dsl.DependencyHandler
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.initialization.Settings
import org.gradle.api.plugins.ExtraPropertiesExtension
import org.gradle.api.provider.Provider
import org.gradle.internal.extensions.stdlib.capitalized
import org.gradle.kotlin.dsl.create
import org.gradle.kotlin.dsl.extra
import org.gradle.plugin.use.PluginDependency
import java.io.File

val Provider<PluginDependency>.gradlePlugin: String
    get() = get().run { "$pluginId:$pluginId.gradle.plugin:$version" }

fun DependencyHandler.implementation(plugin: Provider<PluginDependency>) = add("implementation", plugin.gradlePlugin)

abstract class BuildSrcCatalogPluginExtension {
    abstract val src: RegularFileProperty // ConfigurableFileCollection
    abstract val dst: RegularFileProperty
    abstract val timestampFile: DirectoryProperty
}

private const val versionsToml = ".versions.toml"

/**
 * A simple 'hello world' plugin.
 */
class BuildSrcCatalogPlugin : Plugin<Settings> {

    override fun apply(target: Settings) {

//        println("apply $target")
//        val settings = target.extensions.create<BuildSrcCatalogPluginExtension>("buildSrc-catalog").apply {
//            println("rootDirectory: ${target.layout.rootDirectory}")
//            val buildSrc = target.layout.rootDirectory
//            //            val libs = buildSrc.dir("../gradle").asFile.list { _, name -> name.endsWith(".versions.toml") }
//            val libs = buildSrc.file("../gradle/$libsꓸversionsꓸtoml")
//            src.convention(libs)
//            dst.convention(src.map {
////                val name = it.asFile.name.substringBefore(".versions.toml")
//                buildSrc.file("src/main/kotlin/libs.kt")
//            })
//            timestampFile.convention(buildSrc.dir("buildSrc-catalog"))
//        }

        target.dependencyResolutionManagement {
            versionCatalogs {
                val root = target.layout.rootDirectory
                val libs = root.file("../gradle/$libsꓸversionsꓸtoml").asFile
                if (libs.exists()) {
                    //                    for (file in dir.asFile.parentFile.resolve("gradle").listFiles())
                    //                        if (file.name.endsWith(versionsToml)) {
                    //                            create(file.name.substringBefore(versionsToml)) {
                    //                                from(dir.files("../gradle/${file.name}"))
                    //                            }
                    //                            generate(file, target.gradle.extra)
                    //                        }
                    maybeCreate("libs").from(root.files(libs))
                    val timestamp = libs.parentFile.parentFile.resolve("buildSrc/build/catalog/$libsꓸversionsꓸtoml timestamp")
                    val ext = target.gradle.extra
                    if (timestamp.exists()) {
                        val lastModified = timestamp.readText().toLong()
//                        println("${libs.lastModified()} < $lastModified = " + (libs.lastModified() > lastModified))
                        if (libs.lastModified() > lastModified)
                            generate(libs, ext)
//                        else
//                            println("generation UP-TO-DATE")
                    } else
                        generate(libs, ext)
                } else {
                    // delete generated catalog and build cache
                    root.file("src/main/kotlin/libs.kt").asFile.delete()
                    root.file("../build/buildSrc-catalog").asFile.deleteRecursively()
                }
            }
        }

//        println(target.gradle.extra["plugins"])
    }

    private fun generate(toml: File, ext: ExtraPropertiesExtension) {
//        println("generate $toml")
        //        println(ext)
        // clear plugins cache
//        TODO()
//        if (ext.has("plugins"))
//            ext.set("plugins", mutableMapOf<String, Pair<String, String>>())

        val libName = toml.name.substringBefore(versionsToml)

        val versions = mutableMapOf<String, String>()
        val bundles = ArrayList<String>()
        val libraries = ArrayList<String>()
        val plugins = mutableMapOf<String, Pair<String, String>>()
        lateinit var parse: ((List<String>) -> Unit)

        for (line in toml.readLines()) {
            if (line.isBlank() || line.isEmpty() || line.startsWith('#'))
                continue
            when (line) {
                "[versions]" -> parse = { versions[it[0]] = it[1] }
                "[bundles]" -> parse = { bundles += it[0] }
                "[libraries]" -> parse = { libraries += it[0] }
                "[plugins]" -> parse = {
                    val id = it[2].substringAfter('"').substringBefore('"')
                    val v = it[3].substringAfter('"').substringBefore('"')
                    plugins[it[0]] = id to if (it[2].last() == 'f') versions[v]!! else v
                }
                else -> parse(line.split(" = "))
            }
        }

        val code = buildString {
            operator fun String.unaryPlus() = appendLine(this)

            +"""
                import org.gradle.api.Project
                import org.gradle.api.artifacts.ExternalModuleDependencyBundle
                import org.gradle.api.artifacts.MinimalExternalModuleDependency
                import org.gradle.api.artifacts.VersionCatalogsExtension
                import org.gradle.api.provider.Provider
                import org.gradle.kotlin.dsl.getByType
                import org.gradle.kotlin.dsl.PluginDependenciesSpecScope
                import org.gradle.plugin.use.PluginDependency

                val Project.$libName
                    get() = ${libName.capitalized()}(this)

                class ${libName.capitalized()}(private val project: Project) {
                    private val catalog = project.extensions.getByType<VersionCatalogsExtension>().named("$libName")
                    private val String.version: Provider<String>
                        get() = project.providers.provider {
                            catalog.findVersion(this).get().run {
                                requiredVersion.ifBlank { strictVersion.ifBlank { preferredVersion } }
                            }
                        }
                    private val String.library: Provider<MinimalExternalModuleDependency>
                        get() = catalog.findLibrary(this).get()
                    private val String.bundle: Provider<ExternalModuleDependencyBundle>
                        get() = catalog.findBundle(this).get()
                    private val String.plugin: Provider<PluginDependency>
                        get() = catalog.findPlugin(this).get()

                    val versions
                        get() = Versions()

                    inner class Versions {""".trimIndent()

            // Generate the Versions
            for ((version, _) in versions)
                +"        val $version: Provider<String> get() = \"$version\".version"
            +"    }\n"

            // Generate the Libraries
            for (library in libraries)
                +"    val ${library.maybeBackticks()}: Provider<MinimalExternalModuleDependency> get() = \"${library.dotted()}\".library"

            // Generate the Bundles
            +"""|
                |    val bundles
                |        get() = Bundles()
                |
                |    inner class Bundles {""".trimMargin()
            for (bundle in bundles)
                +"        val ${bundle.maybeBackticks()}: Provider<ExternalModuleDependencyBundle> get() = \"${bundle.dotted()}\".bundle"
            +"    }"

            // Generate the Plugins for dependencies
            +"""|
                |    val plugins
                |       get() = Plugins()
                |
                |    inner class Plugins {""".trimMargin()
            for (plugin in plugins.keys)
                +"        val ${plugin.maybeBackticks()}: Provider<PluginDependency> get() = \"${plugin.dotted()}\".plugin"
            +"    }\n}"

            // Generate dummy placeholders for the precompiled-plugins `plugins {}` block
            //            val extPlugins = if (ext.has("plugins")) ext["plugins"] as Map<String, Pair<String, String>> else emptyMap()
            //            println(plugins)
            //            println(extPlugins)
            for (plugin in plugins.keys)
            // skip duplicates
            //                if (plugin !in extPlugins.keys)
                +"val PluginDependenciesSpecScope.${plugin.maybeBackticks()} get() = Unit"
        }

        // cache the results
//        println("cache the results")
        //        ext["versions"] = versions
        ext["plugins"] = plugins
//        ext[libsꓸversionsꓸtoml] = toml.lastModified()
        toml.parentFile.parentFile.resolve("buildSrc/build/catalog").apply {
            resolve("$libsꓸversionsꓸtoml timestamp").apply {
                parentFile.mkdirs()
                createNewFile()
                writeText(toml.lastModified().toString())
            }
            resolve("plugins").apply {
                createNewFile()
                writeText(plugins.entries.joinToString(",") { "${it.key}=${it.value.first}" })
            }
        }
//        println(toml.lastModified())
        //        println(ext["plugins"])

        toml.parentFile.resolve("../buildSrc/src/main/kotlin/$libName.kt").apply {
            parentFile.mkdirs()
            writeText(code)
        }
    }

    private fun String.toCamelCase(): String = split("-", "_", ".").joinToString("") { it.capitalize() }.decapitalize()
    private fun String.maybeBackticks(): String = if ('-' in this) "`$this`" else this
    private fun String.dotted(): String = replace('-', '.')
    private val lisuLetterToneMyaTi = 'ꓸ'
    private fun String.fix(): String = replace('.', lisuLetterToneMyaTi)
    companion object {
        const val libsꓸversionsꓸtoml = "libs.versions.toml"
    }
}
